import PDFDocument from 'pdfkit';
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Lazy loading singletons
let dbInstance = null;
let auditServiceInstance = null;

const getDb = async () => {
  if (!dbInstance) {
    const { default: db } = await import('../database/db.js');
    dbInstance = db;
  }
  return dbInstance;
};

const getAuditService = async () => {
  if (!auditServiceInstance) {
    const { default: AuditService } = await import('./auditService.js');
    auditServiceInstance = AuditService;
  }
  return auditServiceInstance;
};

class ComplianceReportService {
  constructor() {
    this.reportsDir = path.join(__dirname, '../reports/compliance');
    this.ensureReportsDir();
  }

  async ensureReportsDir() {
    try {
      await fs.mkdir(this.reportsDir, { recursive: true });
    } catch (err) {
      console.error('Error creating reports directory:', err);
    }
  }

  async generateSOXReport(periodStart, periodEnd, generatedBy) {
    const AuditService = await getAuditService();
    const auditData = await AuditService.getAuditTrail({
      startDate: periodStart,
      endDate: periodEnd
    });
    
    const fileName = `SOX_Compliance_${periodStart}_${periodEnd}.pdf`;
    const filePath = path.join(this.reportsDir, fileName);
    
    const doc = new PDFDocument();
    const fs = await import('fs');
    const stream = doc.pipe(fs.default.createWriteStream(filePath));
    
    // Header
    doc.fontSize(20).text('SOX Compliance Report', { align: 'center' });
    doc.moveDown();
    doc.fontSize(12).text(`Period: ${periodStart} to ${periodEnd}`);
    doc.text(`Generated: ${new Date().toISOString()}`);
    doc.text(`Generated By: ${generatedBy}`);
    doc.moveDown();
    
    // Audit Trail Summary
    doc.fontSize(16).text('Audit Trail Summary');
    doc.fontSize(10).text(`Total Audit Entries: ${auditData.length}`);
    doc.moveDown();
    
    // Integrity Verification
    const integrity = await AuditService.verifyAuditChain();
    doc.fontSize(14).text('Data Integrity Verification');
    doc.fontSize(10).text(`Status: ${integrity.isValid ? 'PASSED ✓' : 'FAILED ✗'}`);
    doc.text(`Total Entries Verified: ${integrity.totalEntries}`);
    if (!integrity.isValid) {
      doc.text(`Invalid Entries: ${integrity.invalidEntries.join(', ')}`);
    }
    doc.moveDown();
    
    // Access Controls
    doc.fontSize(14).text('Access Control Summary');
    const userActions = this.groupByUser(auditData);
    Object.entries(userActions).forEach(([user, count]) => {
      doc.fontSize(10).text(`${user}: ${count} actions`);
    });
    
    doc.end();
    
    await new Promise(resolve => stream.on('finish', resolve));
    
    return this.saveReportMetadata('SOX', 'SOX', periodStart, periodEnd, generatedBy, filePath);
  }

  async generateISOReport(periodStart, periodEnd, generatedBy) {
    const fileName = `ISO_27001_${periodStart}_${periodEnd}.pdf`;
    const filePath = path.join(this.reportsDir, fileName);
    
    const doc = new PDFDocument();
    const fs = await import('fs');
    const stream = doc.pipe(fs.default.createWriteStream(filePath));
    
    doc.fontSize(20).text('ISO 27001 Compliance Report', { align: 'center' });
    doc.moveDown();
    doc.fontSize(12).text(`Period: ${periodStart} to ${periodEnd}`);
    doc.moveDown();
    
    // Information Security Controls
    doc.fontSize(16).text('Information Security Controls');
    doc.fontSize(10).text('✓ Access control mechanisms implemented');
    doc.text('✓ Audit logging enabled and monitored');
    doc.text('✓ Data encryption in transit and at rest');
    doc.text('✓ Regular security assessments conducted');
    doc.moveDown();
    
    // Audit Trail
    const AuditService = await getAuditService();
    const auditData = await AuditService.getAuditTrail({
      startDate: periodStart,
      endDate: periodEnd
    });
    
    doc.fontSize(14).text('Audit Trail Statistics');
    doc.fontSize(10).text(`Total Events: ${auditData.length}`);
    doc.text(`Security Events: ${auditData.filter(a => a.action.includes('security')).length}`);
    doc.text(`Access Events: ${auditData.filter(a => a.action.includes('access')).length}`);
    
    doc.end();
    await new Promise(resolve => stream.on('finish', resolve));
    
    return this.saveReportMetadata('ISO', 'ISO 27001', periodStart, periodEnd, generatedBy, filePath);
  }

  async generateGDPRReport(periodStart, periodEnd, generatedBy) {
    const fileName = `GDPR_Compliance_${periodStart}_${periodEnd}.pdf`;
    const filePath = path.join(this.reportsDir, fileName);
    
    const doc = new PDFDocument();
    const fs = await import('fs');
    const stream = doc.pipe(fs.default.createWriteStream(filePath));
    
    doc.fontSize(20).text('GDPR Compliance Report', { align: 'center' });
    doc.moveDown();
    
    // Data Processing Activities
    doc.fontSize(16).text('Data Processing Activities');
    const AuditService = await getAuditService();
    const auditData = await AuditService.getAuditTrail({
      startDate: periodStart,
      endDate: periodEnd
    });
    
    doc.fontSize(10).text(`Total Data Operations: ${auditData.length}`);
    doc.text(`Data Access Events: ${auditData.filter(a => a.action === 'read').length}`);
    doc.text(`Data Modifications: ${auditData.filter(a => a.action === 'update').length}`);
    doc.text(`Data Deletions: ${auditData.filter(a => a.action === 'delete').length}`);
    doc.moveDown();
    
    // Rights Exercised
    doc.fontSize(14).text('Data Subject Rights');
    doc.fontSize(10).text('✓ Right to access implemented');
    doc.text('✓ Right to rectification available');
    doc.text('✓ Right to erasure functional');
    doc.text('✓ Data portability supported');
    
    doc.end();
    await new Promise(resolve => stream.on('finish', resolve));
    
    return this.saveReportMetadata('GDPR', 'GDPR', periodStart, periodEnd, generatedBy, filePath);
  }

  async saveReportMetadata(reportType, framework, periodStart, periodEnd, generatedBy, filePath) {
    const db = await getDb();
    return new Promise((resolve, reject) => {
      const stmt = db.prepare(`
        INSERT INTO compliance_reports (report_type, framework, period_start, period_end, 
          generated_by, file_path, status)
        VALUES (?, ?, ?, ?, ?, ?, ?)
      `);
      
      stmt.run([reportType, framework, periodStart, periodEnd, generatedBy, filePath, 'completed'],
      function(err) {
        if (err) reject(err);
        else resolve({ id: this.lastID, filePath });
      });
      
      stmt.finalize();
    });
  }

  groupByUser(auditData) {
    return auditData.reduce((acc, entry) => {
      acc[entry.user_id] = (acc[entry.user_id] || 0) + 1;
      return acc;
    }, {});
  }

  async getReports(filters = {}) {
    const db = await getDb();
    return new Promise((resolve, reject) => {
      let query = 'SELECT * FROM compliance_reports WHERE 1=1';
      const params = [];
      
      const validReportTypes = ['SOX', 'ISO', 'GDPR'];
      if (filters.reportType && validReportTypes.includes(filters.reportType)) {
        query += ' AND report_type = ?';
        params.push(filters.reportType);
      }
      
      query += ' ORDER BY generated_at DESC';
      
      const stmt = db.prepare(query);
      stmt.all(params, (err, rows) => {
        if (err) reject(err);
        else resolve(rows);
      });
      stmt.finalize();
    });
  }
}

export default new ComplianceReportService();
